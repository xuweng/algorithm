package com.leetcode.tag.dfs.two;

import java.util.*;

/**
 * 928. 尽量减少恶意软件的传播 II
 */
public class MinMalwareSpread2 {
    /**
     * 方法一： 深度优先搜索
     * <p>
     * 作者：LeetCode
     * 链接：https://leetcode-cn.com/problems/minimize-malware-spread-ii/solution/jin-liang-jian-shao-e-yi-ruan-jian-de-chuan-bo-ii-/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     */
    class Solution {
        public int minMalwareSpread(int[][] graph, int[] initial) {
            int N = graph.length;
            int[] clean = new int[N];
            Arrays.fill(clean, 1);
            for (int x : initial) {
                clean[x] = 0;
            }

            // For each node u in initial, dfs to find
            // 'seen': all nodes not in initial that it can reach.
            ArrayList<Integer>[] infectedBy = new ArrayList[N];
            for (int i = 0; i < N; ++i) {
                infectedBy[i] = new ArrayList<>();
            }

            for (int u : initial) {
                Set<Integer> seen = new HashSet<>();
                dfs(graph, clean, u, seen);
                for (int v : seen) {
                    infectedBy[v].add(u);
                }
            }

            // For each node u in initial, for every v not in initial
            // that is uniquely infected by u, add 1 to the contribution for u.
            int[] contribution = new int[N];
            for (int v = 0; v < N; ++v) {
                if (infectedBy[v].size() == 1) {
                    contribution[infectedBy[v].get(0)]++;
                }
            }

            // Take the best answer.
            Arrays.sort(initial);
            int ans = initial[0], ansSize = -1;
            for (int u : initial) {
                int score = contribution[u];
                if (score > ansSize || score == ansSize && u < ans) {
                    ans = u;
                    ansSize = score;
                }
            }
            return ans;
        }

        public void dfs(int[][] graph, int[] clean, int u, Set<Integer> seen) {
            for (int v = 0; v < graph.length; ++v) {
                if (graph[u][v] == 1 && clean[v] == 1 && !seen.contains(v)) {
                    seen.add(v);
                    dfs(graph, clean, v, seen);
                }
            }
        }
    }

    /**
     * 方法二： 并查集
     * <p>
     * 作者：LeetCode
     * 链接：https://leetcode-cn.com/problems/minimize-malware-spread-ii/solution/jin-liang-jian-shao-e-yi-ruan-jian-de-chuan-bo-ii-/
     * 来源：力扣（LeetCode）
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     */
    class Solution1 {
        public int minMalwareSpread(int[][] graph, int[] initial) {
            int N = graph.length;
            DSU dsu = new DSU(N);

            // clean[u] == 1 if its a node in the graph not in initial.
            int[] clean = new int[N];
            Arrays.fill(clean, 1);
            for (int x : initial) {
                clean[x] = 0;
            }

            for (int u = 0; u < N; ++u) {
                if (clean[u] == 1) {
                    for (int v = 0; v < N; ++v) {
                        if (clean[v] == 1) {
                            if (graph[u][v] == 1) {
                                dsu.union(u, v);
                            }
                        }
                    }
                }
            }

            // dsu now represents the components of the graph without
            // any nodes from initial.  Let's call this graph G.
            int[] count = new int[N];
            Map<Integer, Set<Integer>> nodeToCompo = new HashMap<>();
            for (int u : initial) {
                Set<Integer> components = new HashSet<>();
                for (int v = 0; v < N; ++v) {
                    if (clean[v] == 1) {
                        if (graph[u][v] == 1) {
                            components.add(dsu.find(v));
                        }
                    }
                }

                nodeToCompo.put(u, components);
                for (int c : components) {
                    count[c]++;
                }
            }

            // For each node u in initial, nodeToCompo.get(u)
            // now has every component from G that u neighbors.

            int ans = -1, ansSize = -1;
            for (int u : nodeToCompo.keySet()) {
                Set<Integer> components = nodeToCompo.get(u);
                int score = 0;
                for (int c : components) {
                    if (count[c] == 1) // uniquely infected
                    {
                        score += dsu.size(c);
                    }
                }

                if (score > ansSize || score == ansSize && u < ans) {
                    ansSize = score;
                    ans = u;
                }
            }

            return ans;
        }
    }


    class DSU {
        int[] p, sz;

        DSU(int N) {
            p = new int[N];
            for (int x = 0; x < N; ++x) {
                p[x] = x;
            }

            sz = new int[N];
            Arrays.fill(sz, 1);
        }

        public int find(int x) {
            if (p[x] != x) {
                p[x] = find(p[x]);
            }
            return p[x];
        }

        public void union(int x, int y) {
            int xr = find(x);
            int yr = find(y);
            p[xr] = yr;
            sz[yr] += sz[xr];
        }

        public int size(int x) {
            return sz[find(x)];
        }
    }


}
